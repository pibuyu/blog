// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.26.0--rc3
// source: user.proto

package user

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	UserService_Login_FullMethodName                           = "/rpc.UserService/Login"
	UserService_GetUserInfo_FullMethodName                     = "/rpc.UserService/GetUserInfo"
	UserService_GetUserRepositoryByUserIdentity_FullMethodName = "/rpc.UserService/GetUserRepositoryByUserIdentity"
	UserService_DeleteUserRepositoryByIdentity_FullMethodName  = "/rpc.UserService/DeleteUserRepositoryByIdentity"
	UserService_RegisterSendCode_FullMethodName                = "/rpc.UserService/RegisterSendCode"
	UserService_UserRegister_FullMethodName                    = "/rpc.UserService/UserRegister"
	UserService_KafkaSendTestcase_FullMethodName               = "/rpc.UserService/KafkaSendTestcase"
	UserService_KafkaReceiveTestcase_FullMethodName            = "/rpc.UserService/KafkaReceiveTestcase"
	UserService_UserIsExist_FullMethodName                     = "/rpc.UserService/UserIsExist"
	UserService_CreateOrder_FullMethodName                     = "/rpc.UserService/CreateOrder"
	UserService_RoomStockDeduct_FullMethodName                 = "/rpc.UserService/RoomStockDeduct"
	UserService_RoomIsExist_FullMethodName                     = "/rpc.UserService/RoomIsExist"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*GetUserInfoResponse, error)
	GetUserRepositoryByUserIdentity(ctx context.Context, in *GetUserRepositoryByUserIdentityRequest, opts ...grpc.CallOption) (*GetUserRepositoryByUserIdentityResponse, error)
	DeleteUserRepositoryByIdentity(ctx context.Context, in *DeleteUserRepositoryByIdentityRequest, opts ...grpc.CallOption) (*DeleteUserRepositoryByIdentityResponse, error)
	RegisterSendCode(ctx context.Context, in *RegisterSendCodeRequest, opts ...grpc.CallOption) (*RegisterSendCodeResponse, error)
	UserRegister(ctx context.Context, in *UserRegisterRequest, opts ...grpc.CallOption) (*UserRegisterResponse, error)
	KafkaSendTestcase(ctx context.Context, in *KafkaSendTestcaseRequest, opts ...grpc.CallOption) (*KafkaSendTestcaseResponse, error)
	KafkaReceiveTestcase(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*KafkaReceiveTestcaseResponse, error)
	UserIsExist(ctx context.Context, in *UserIsExistRequest, opts ...grpc.CallOption) (*UserIsExistResponse, error)
	CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*CreateOrderResponse, error)
	RoomStockDeduct(ctx context.Context, in *RoomStockDeductRequest, opts ...grpc.CallOption) (*RoomStockDeductResponse, error)
	RoomIsExist(ctx context.Context, in *RoomIsExistRequest, opts ...grpc.CallOption) (*RoomIsExistResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, UserService_Login_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*GetUserInfoResponse, error) {
	out := new(GetUserInfoResponse)
	err := c.cc.Invoke(ctx, UserService_GetUserInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserRepositoryByUserIdentity(ctx context.Context, in *GetUserRepositoryByUserIdentityRequest, opts ...grpc.CallOption) (*GetUserRepositoryByUserIdentityResponse, error) {
	out := new(GetUserRepositoryByUserIdentityResponse)
	err := c.cc.Invoke(ctx, UserService_GetUserRepositoryByUserIdentity_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUserRepositoryByIdentity(ctx context.Context, in *DeleteUserRepositoryByIdentityRequest, opts ...grpc.CallOption) (*DeleteUserRepositoryByIdentityResponse, error) {
	out := new(DeleteUserRepositoryByIdentityResponse)
	err := c.cc.Invoke(ctx, UserService_DeleteUserRepositoryByIdentity_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) RegisterSendCode(ctx context.Context, in *RegisterSendCodeRequest, opts ...grpc.CallOption) (*RegisterSendCodeResponse, error) {
	out := new(RegisterSendCodeResponse)
	err := c.cc.Invoke(ctx, UserService_RegisterSendCode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UserRegister(ctx context.Context, in *UserRegisterRequest, opts ...grpc.CallOption) (*UserRegisterResponse, error) {
	out := new(UserRegisterResponse)
	err := c.cc.Invoke(ctx, UserService_UserRegister_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) KafkaSendTestcase(ctx context.Context, in *KafkaSendTestcaseRequest, opts ...grpc.CallOption) (*KafkaSendTestcaseResponse, error) {
	out := new(KafkaSendTestcaseResponse)
	err := c.cc.Invoke(ctx, UserService_KafkaSendTestcase_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) KafkaReceiveTestcase(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*KafkaReceiveTestcaseResponse, error) {
	out := new(KafkaReceiveTestcaseResponse)
	err := c.cc.Invoke(ctx, UserService_KafkaReceiveTestcase_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UserIsExist(ctx context.Context, in *UserIsExistRequest, opts ...grpc.CallOption) (*UserIsExistResponse, error) {
	out := new(UserIsExistResponse)
	err := c.cc.Invoke(ctx, UserService_UserIsExist_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*CreateOrderResponse, error) {
	out := new(CreateOrderResponse)
	err := c.cc.Invoke(ctx, UserService_CreateOrder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) RoomStockDeduct(ctx context.Context, in *RoomStockDeductRequest, opts ...grpc.CallOption) (*RoomStockDeductResponse, error) {
	out := new(RoomStockDeductResponse)
	err := c.cc.Invoke(ctx, UserService_RoomStockDeduct_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) RoomIsExist(ctx context.Context, in *RoomIsExistRequest, opts ...grpc.CallOption) (*RoomIsExistResponse, error) {
	out := new(RoomIsExistResponse)
	err := c.cc.Invoke(ctx, UserService_RoomIsExist_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error)
	GetUserRepositoryByUserIdentity(context.Context, *GetUserRepositoryByUserIdentityRequest) (*GetUserRepositoryByUserIdentityResponse, error)
	DeleteUserRepositoryByIdentity(context.Context, *DeleteUserRepositoryByIdentityRequest) (*DeleteUserRepositoryByIdentityResponse, error)
	RegisterSendCode(context.Context, *RegisterSendCodeRequest) (*RegisterSendCodeResponse, error)
	UserRegister(context.Context, *UserRegisterRequest) (*UserRegisterResponse, error)
	KafkaSendTestcase(context.Context, *KafkaSendTestcaseRequest) (*KafkaSendTestcaseResponse, error)
	KafkaReceiveTestcase(context.Context, *Empty) (*KafkaReceiveTestcaseResponse, error)
	UserIsExist(context.Context, *UserIsExistRequest) (*UserIsExistResponse, error)
	CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error)
	RoomStockDeduct(context.Context, *RoomStockDeductRequest) (*RoomStockDeductResponse, error)
	RoomIsExist(context.Context, *RoomIsExistRequest) (*RoomIsExistResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedUserServiceServer) GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedUserServiceServer) GetUserRepositoryByUserIdentity(context.Context, *GetUserRepositoryByUserIdentityRequest) (*GetUserRepositoryByUserIdentityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserRepositoryByUserIdentity not implemented")
}
func (UnimplementedUserServiceServer) DeleteUserRepositoryByIdentity(context.Context, *DeleteUserRepositoryByIdentityRequest) (*DeleteUserRepositoryByIdentityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserRepositoryByIdentity not implemented")
}
func (UnimplementedUserServiceServer) RegisterSendCode(context.Context, *RegisterSendCodeRequest) (*RegisterSendCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterSendCode not implemented")
}
func (UnimplementedUserServiceServer) UserRegister(context.Context, *UserRegisterRequest) (*UserRegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister not implemented")
}
func (UnimplementedUserServiceServer) KafkaSendTestcase(context.Context, *KafkaSendTestcaseRequest) (*KafkaSendTestcaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KafkaSendTestcase not implemented")
}
func (UnimplementedUserServiceServer) KafkaReceiveTestcase(context.Context, *Empty) (*KafkaReceiveTestcaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KafkaReceiveTestcase not implemented")
}
func (UnimplementedUserServiceServer) UserIsExist(context.Context, *UserIsExistRequest) (*UserIsExistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserIsExist not implemented")
}
func (UnimplementedUserServiceServer) CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrder not implemented")
}
func (UnimplementedUserServiceServer) RoomStockDeduct(context.Context, *RoomStockDeductRequest) (*RoomStockDeductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoomStockDeduct not implemented")
}
func (UnimplementedUserServiceServer) RoomIsExist(context.Context, *RoomIsExistRequest) (*RoomIsExistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoomIsExist not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserInfo(ctx, req.(*GetUserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserRepositoryByUserIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRepositoryByUserIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserRepositoryByUserIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserRepositoryByUserIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserRepositoryByUserIdentity(ctx, req.(*GetUserRepositoryByUserIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUserRepositoryByIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRepositoryByIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUserRepositoryByIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUserRepositoryByIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUserRepositoryByIdentity(ctx, req.(*DeleteUserRepositoryByIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_RegisterSendCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterSendCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).RegisterSendCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_RegisterSendCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).RegisterSendCode(ctx, req.(*RegisterSendCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UserRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UserRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UserRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UserRegister(ctx, req.(*UserRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_KafkaSendTestcase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KafkaSendTestcaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).KafkaSendTestcase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_KafkaSendTestcase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).KafkaSendTestcase(ctx, req.(*KafkaSendTestcaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_KafkaReceiveTestcase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).KafkaReceiveTestcase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_KafkaReceiveTestcase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).KafkaReceiveTestcase(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UserIsExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIsExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UserIsExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UserIsExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UserIsExist(ctx, req.(*UserIsExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateOrder(ctx, req.(*CreateOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_RoomStockDeduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomStockDeductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).RoomStockDeduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_RoomStockDeduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).RoomStockDeduct(ctx, req.(*RoomStockDeductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_RoomIsExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomIsExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).RoomIsExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_RoomIsExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).RoomIsExist(ctx, req.(*RoomIsExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _UserService_Login_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _UserService_GetUserInfo_Handler,
		},
		{
			MethodName: "GetUserRepositoryByUserIdentity",
			Handler:    _UserService_GetUserRepositoryByUserIdentity_Handler,
		},
		{
			MethodName: "DeleteUserRepositoryByIdentity",
			Handler:    _UserService_DeleteUserRepositoryByIdentity_Handler,
		},
		{
			MethodName: "RegisterSendCode",
			Handler:    _UserService_RegisterSendCode_Handler,
		},
		{
			MethodName: "UserRegister",
			Handler:    _UserService_UserRegister_Handler,
		},
		{
			MethodName: "KafkaSendTestcase",
			Handler:    _UserService_KafkaSendTestcase_Handler,
		},
		{
			MethodName: "KafkaReceiveTestcase",
			Handler:    _UserService_KafkaReceiveTestcase_Handler,
		},
		{
			MethodName: "UserIsExist",
			Handler:    _UserService_UserIsExist_Handler,
		},
		{
			MethodName: "CreateOrder",
			Handler:    _UserService_CreateOrder_Handler,
		},
		{
			MethodName: "RoomStockDeduct",
			Handler:    _UserService_RoomStockDeduct_Handler,
		},
		{
			MethodName: "RoomIsExist",
			Handler:    _UserService_RoomIsExist_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}
